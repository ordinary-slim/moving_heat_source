#include "mesh.h"
#include "../../external/pybind11/include/pybind11/pybind11.h"
#include "../../external/pybind11/include/pybind11/eigen.h"
#include "../../external/pybind11/include/pybind11/stl.h"

namespace py = pybind11;

void mesh::Mesh::initializeMesh(py::dict &input) {
  // 1D generated by software
  if (input.contains("1D")) {
    double a = py::cast<double>(input["Left"]);
    double b = py::cast<double>(input["Right"]);
    int nels = py::cast<int>( input["nels"] );
    generate1DMesh( a, b, nels );
  } else {
    //SET ELEMENT TYPE
    ElementType cell_type_flag;
    string aux_cell_type = py::cast<string>( input["cell_type"] );
    if        (aux_cell_type == "line2") {
      cell_type_flag = line2;
    } else if (aux_cell_type == "triangle3") {
      cell_type_flag = triangle3;
    } else if (aux_cell_type == "quad4") {
      cell_type_flag = quad4;
    }
    // reference element. no support for mixed meshes yet
    refEl = refElement(cell_type_flag);

    //READ POINTS
    py::array points = input["points"];
    nnodes = points.shape(0);
    dim    = points.shape(1);
    pos.resize( nnodes, 3 );
    pos_noAdv.resize( nnodes, 3 );
    pos.setZero();
    auto aux_points = points.unchecked<double>();
    for ( int ipoint = 0; ipoint < nnodes; ipoint++) {
      for ( int idim = 0; idim < dim; idim++) {
        pos(ipoint, idim) =  aux_points(ipoint, idim);
      }
    }
    pos_noAdv = pos;
    //READ ELEMENTS
    py::array cells    = input["cells"];
    nels          = cells.shape(0);
    nnodes_per_el = cells.shape(1);
    con_CellPoint.con.resize( nels, nnodes_per_el );
    elementTypes.resize( nels );
    activeElements.resize( nels );
    activeNodes.resize( nnodes );
    con_CellPoint.con.setOnes();
    con_CellPoint.con *= -1;
    auto aux_cells = cells.unchecked<int>();//Receiving uint here breaks code
    for ( int icell = 0; icell < nels; icell++) {
      for ( int inode = 0; inode < nnodes_per_el; inode++) {
        con_CellPoint.con(icell, inode) =  aux_cells(icell, inode);
      }
    }
    std::fill (elementTypes.begin(), elementTypes.end(), 
        cell_type_flag);
    std::fill (activeElements.begin(), activeElements.end(), 
        1);//all elements start active
  }
  // reference element. no support for mixed s yet

  //Manually fill D0 connectivity fields
  con_CellPoint.oDim = refEl.dim;
  con_CellPoint.tDim = 0;
  con_CellPoint.nels_oDim = nels;
  con_CellPoint.nels_tDim = nnodes;
  con_CellPoint.oelType = refEl.elementType;
  con_CellPoint.telType = point1;
  //CONNECTIVITIES
  Connectivity con_PointCell = mesh::transpose( con_CellPoint );
  con_CellCell = mesh::intersect( con_CellPoint, con_PointCell );
  Connectivity con_CellFacet;
  tie(con_FacetPoint, con_CellFacet) = mesh::build( refEl.dim-1, con_CellPoint, con_CellCell );
  con_FacetCell = mesh::transpose(con_CellFacet);

}
